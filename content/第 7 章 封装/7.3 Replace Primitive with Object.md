---
title: 7.3 以对象取代基本类型（Replace Primitive with Object）
aliases:
  - 以对象取代基本类型
---

曾用名：以对象取代数据值（Replace Data Value with Object）

曾用名：以类取代类型码（Replace Type Code with Class）

```js
  orders.filter(o => "high" === o.priority
               || "rush" === o.priority);


  orders.filter(o => o.priority.higherThan(new Priority("normal")))
```

### 动机

开发初期，你往往决定以简单的数据项表示简单的情况，比如使用数字或字符串等。但随着开发的进行，你可能会发现，这些简单数据项不再那么简单了。比如说，一开始你可能会用一个字符串来表示“电话号码”的概念，但是随后它又需要“格式化”“抽取区号”之类的特殊行为。这类逻辑很快便会占领代码库，制造出许多重复代码，增加使用时的成本。

一旦我发现对某个数据的操作不仅仅局限于打印时，我就会为它创建一个新类。一开始这个类也许只是简单包装一下简单类型的数据，不过只要类有了，日后添加的业务逻辑就有地可去了。这些小小的封装值开始可能价值甚微，但只要悉心照料，它们很快便能成长为有用的工具。创建新类无须太大的工作量，但我发现它们往往对代码库有深远的影响。实际上，许多经验丰富的开发者认为，这是他们的工具箱里最实用的重构手法之一——尽管其价值常为新手程序员所低估。

### 做法

如果变量尚未被封装起来，先使用[[../第 6 章 第一组重构/6.6 Encapsulate Variable|封装变量]]（132）封装它。

为这个数据值创建一个简单的类。类的构造函数应该保存这个数据值，并为它提供一个取值函数。

执行静态检查。

修改第一步得到的设值函数，令其创建一个新类的对象并将其存入字段，如果有必要的话，同时修改字段的类型声明。

修改取值函数，令其调用新类的取值函数，并返回结果。

测试。

考虑对第一步得到的访问函数使用函数改名（124），以便更好反映其用途。

考虑应用[[../第 9 章 重新组织数据/9.4 Change Reference to Value|将引用对象改为值对象]]（252）或[[../第 9 章 重新组织数据/9.5 Change Value to Reference|将值对象改为引用对象]]（256），明确指出新对象的角色是值对象还是引用对象。

### 范例

我将从一个简单的订单（Order）类开始。该类从一个简单的记录结构里读取所需的数据，这其中有一个订单优先级（priority）字段，它是以字符串的形式被读入的。

#### class Order...

```js
  constructor(data) {
  this.priority = data.priority;
  // more initialization
```

客户端代码有些地方是这么用它的：

#### 客户端...

```js
  highPriorityCount = orders.filter(o => "high" === o.priority
                                   || "rush" === o.priority)
                          .length;
```

无论何时，当我与一个数据值打交道时，第一件事一定是对它使用[[../第 6 章 第一组重构/6.6 Encapsulate Variable|封装变量]]（132）。

#### class Order...

```js
get priority()        {return this._priority;}
set priority(aString) {this._priority = aString;}
```

现在构造函数中第一行初始化代码就会使用我刚刚创建的设值函数了。

这使它成了一个自封装的字段，因此我暂可放任原来的引用点不理，先对字段进行处理。

接下来我为优先级字段创建一个简单的值类（value class）。该类应该有一个构造函数接收值字段，并提供一个返回字符串的转换函数。

```js
class Priority {
  constructor(value) {
    this._value = value;
  }
  toString() {
    return this._value;
  }
}
```

这里的转换函数我更倾向于使用 toString 而不用取值函数（value）。对类的客户端而言，一个返回字符串描述的 API 应该更能传达“发生了数据转换”的信息，而使用取值函数取用一个字段就缺乏这方面的感觉。

然后我要修改访问函数，使其用上新创建的类。

#### class Order...

```js
get priority()        {return this._priority.toString();}
set priority(aString) {this._priority = new Priority(aString);}
```

提炼出 Priority 类后，我发觉现在 Order 类上的取值函数命名有点儿误导人了。它确实还是返回了优先级信息，但却是一个字符串描述，而不是一个 Priority 对象。于是我立即对它应用了函数改名（124）。

#### class Order...

```js
get priorityString() {return this._priority.toString();}
set priority(aString) {this._priority = new Priority(aString);}
```

#### 客户端...

```js
  highPriorityCount = orders.filter(o => "high" === o.priorityString
                                   || "rush" === o.priorityString)
                          .length;
```

这里设值函数的名字倒没有使我不满，因为函数的参数能够清晰地表达其意图。

到此为止，正式的重构手法就结束了。不过当我进一步查看优先级字段的客户端时，我在想让它们直接使用 Priority 对象是否会更好。于是，我着手在订单类上添加一个取值函数，让它直接返回新建的 Priority 对象。

#### class Order...

```js
get priority()        {return this._priority;}
get priorityString()  {return this._priority.toString();}
set priority(aString) {this._priority = new Priority(aString);}
```

#### 客户端...

```js
  highPriorityCount = orders.filter(o => "high" === o.priority.toString()
                                   || "rush" === o.priority.toString())
                          .length;
```

随着 Priority 对象在别处也有了用处，我开始支持让 Order 类的客户端拿着 Priority 实例来调用设值函数，这可以通过调整 Priority 类的构造函数实现。

#### class Priority...

```js
constructor(value) {
  if (value instanceof Priority) return value;
  this._value = value;
}
```

这样做的意义在于，现在新的 Priority 类可以容纳更多业务行为——无论是新的业务代码，还是从别处搬移过来的。这里有些例子，它会校验优先级的传入值，支持一些比较逻辑。

#### class Priority...

```js
constructor(value) {
  if (value instanceof Priority) return value;
  if (Priority.legalValues().includes(value))
    this._value = value;
  else
    throw new Error(`<${value}> is invalid for Priority`);
}
toString() {return this._value;}
get _index() {return Priority.legalValues().findIndex(s => s === this._value);}
static legalValues() {return ['low', 'normal', 'high', 'rush'];}

equals(other) {return this._index === other._index;}
higherThan(other) {return this._index > other._index;}
lowerThan(other) {return this._index < other._index;}
```

修改的过程中，我发觉它实际上已经担负起值对象（value object）的角色，因此我又为它添加了一个 equals 方法，并确保它的值不可修改。

加上这些行为后，我可以让客户端代码读起来含义更清晰。

#### 客户端...

```js
  highPriorityCount = orders.filter(o => o.priority.higherThan(new Priority("normal")))
                          .length;
```
